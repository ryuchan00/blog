
# untraceファイル(add前、新しく作ったファイル)に対しての削除方法

```
git clean -f
```

# gitの名前の設定

```
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

# Herokuのbuildpacの扱い

## 現在使用中のbuildpackを表示する

```
heroku buildpacs
1\. https://github.com/heroku/heroku-buildpack-apt
2\. https://github.com/rcaught/heroku-buildpack-cmake
3\. heroku/ruby
```

## buildpacをセットする

```
heroku buildpacks:set "ビルドパック名またはURL"
# ex.
heroku buildpacks:set heroku/ruby # rubyのbuildpack
heroku buildpacks:set https://github.com/heroku/heroku-buildpack-apt # build時にapt-getしてくれるbuildpack
```

## buildpack を追加する

```
heroku buildpacks:add "ビルドパック名またはURL"
# ex.
heroku buildpacks:add --index 1 heroku/nodejs # indexオプションは、buildpackが複数ある時の実行順の指定。
```

## 全てのbuildpackを削除する

```
heroku buildpacks:clear
```

<https://codon-buildpacks.s3.amazonaws.com/buildpacks/frederick/heroku-buildpack-ruby.tgz>

# ipアドレスの確認

```sh
ifconfig
```

# bashの最初の呪文

2種類の shebang

シェルスクリプトの一行目に必ず記述する #! で始まる行を shebang と言います。 bash スクリプトの shebang は、bash を絶対パスで指定する方法と、env を使って指定する方法の二種類あります。

bash を絶対パスを指定する方法

# !/bin/bash

env を使ってを指定する方法

# !/usr/bin/env bash

前者は /bin/bash が使われます。 （/bin/bash が存在しなければスクリプトの起動時にエラーとなります）

後者は $PATH 上の bash が使われます。 （通常、bash は一か所にしか無いので、後者でも /bin/bash となる可能性が高いです。）

後者のメリットは、例えば $HOME/.opt 配下に最新の bash をインストールするなどした場合、$PATH にさえ入っていればそっちが使われるというのがあります。

# Linuxの構成

## Linuxのハードウェア一覧を表示する

```
ubuntu@rails-dev-box:~$ sudo lshw -short
H/W path           Device     Class      Description
====================================================
                              system     VirtualBox
/0                            bus        VirtualBox
/0/0                          memory     128KiB BIOS
/0/1                          memory     1999MiB System memory
/0/2                          processor  Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz
/0/100                        bridge     440FX - 82441FX PMC [Natoma]
/0/100/1                      bridge     82371SB PIIX3 ISA [Natoma/Triton II]
/0/100/1.1                    storage    82371AB/EB/MB PIIX4 IDE
/0/100/2                      display    VirtualBox Graphics Adapter
/0/100/3           enp0s3     network    82540EM Gigabit Ethernet Controller
/0/100/4                      generic    VirtualBox Guest Service
/0/100/7                      bridge     82371AB/EB/MB PIIX4 ACPI
/0/100/14          scsi2      storage    53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI
/0/100/14/0.0.0    /dev/sda   disk       10GB HARDDISK
/0/100/14/0.0.0/1  /dev/sda1  volume     10238MiB EXT4 volume
/0/100/14/0.1.0    /dev/sdb   disk       10MB HARDDISK
```

- processor:CPU
- memory:メモリー
- storage:ストレージ
- display:ディスプレイ
- bus:バス(データの通り道、上記のアーキテクトを繋ぐ役割)

## ストレージの使用率を表示する

```
ubuntu@rails-dev-box:~$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
udev             1002404         0   1002404   0% /dev
tmpfs             204776     23688    181088  12% /run
/dev/sda1       10098432   7707248   2374800  77% /
tmpfs            1023876         0   1023876   0% /dev/shm
tmpfs               5120         0      5120   0% /run/lock
tmpfs            1023876         0   1023876   0% /sys/fs/cgroup
vagrant        243924992 209760196  34164796  86% /vagrant
tmpfs             204772         0    204772   0% /run/user/1000
```

`Use%`が使用率である。

Usedの容量の単位は、オプションで変更可能

```
# M(メガバイト)で表示する
ubuntu@rails-dev-box:~$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            979M     0  979M   0% /dev
tmpfs           200M   24M  177M  12% /run
/dev/sda1       9.7G  7.4G  2.3G  77% /
tmpfs          1000M     0 1000M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs          1000M     0 1000M   0% /sys/fs/cgroup
vagrant         233G  201G   33G  86% /vagrant
tmpfs           200M     0  200M   0% /run/user/1000

# G(ギガバイト)で表示する
ubuntu@rails-dev-box:~$ df -H
Filesystem      Size  Used Avail Use% Mounted on
udev            1.1G     0  1.1G   0% /dev
tmpfs           210M   25M  186M  12% /run
/dev/sda1        11G  7.9G  2.5G  77% /
tmpfs           1.1G     0  1.1G   0% /dev/shm
tmpfs           5.3M     0  5.3M   0% /run/lock
tmpfs           1.1G     0  1.1G   0% /sys/fs/cgroup
vagrant         250G  215G   35G  86% /vagrant
tmpfs           210M     0  210M   0% /run/user/1000
```

# Linuxのファイル権限

Linux の全てのファイルには、

ファイルの所有ユーザー 所属グループ その他のユーザー の 3 つのアカウントの集団に対して

読み込み可能 書き込み可能 実行可能 という 3 つの権限を管理しています。

ここでは、全てのユーザーが、このファイルを実行可能なように設定してみましょう。

```
chmod a+x my-first.sh
```

# ネットワークの知識

## IPアドレス

IP アドレスは、ネットワーク上における住所です。

あるコンピューターが、ネットワーク上の他のコンピューターに情報を送る際には、その送信先の IP アドレスを記述したパケットを送信することになります。

## TCP

TCPとは、Transmission Control Protocol の略称です。

IP によるパケットを使った通信で、相手の通信状況を確認して接続を確立して、データの転送が終わったら切断するというプロトコルです。

相手との接続を確立しないでいきなりデータを送る方式に、 UDP (User Datagram Protocol) というものもあり、こちらは確実性よりも転送効率を重視する場合に用いられます。

# HTTPまとめ

HTTP は、HTML などの情報をやりとりする TCP/IP 上のプロトコル

HTTPS は、HTTP を暗号化したもの

DNS は、ホスト名を IP アドレスに引き換えてくれる

# 和田さん

# テーマは「学習方法のHowTo」

## 1."四半期ごとに技術書を読む"

### 読書

技術書をリニア(速読)せずに読んで行くのはよくない。

**技術書の読み方は、複数冊読んで、差分を抽出して読む。**

徳丸先生も、「新しい技術は既存技術の差分として習得する」ことがベストプラクティスとしている。

記憶の分類は3つある。

- 感覚記憶
- 短期記憶
- 長期記憶

### 1.脳内インデックスを作る

**記憶のピッカーを育てる = 反復練習**

短期記憶を複数回実行 -> 長期記憶へと昇華

読書は時系列に読む。

**つまり、書籍同士のリレーション関係をみる(参照書籍etc...)**

ここではRailsを例に出して説明している。

Railsは2004年に出てきて、Webアプリケーションの作り方が大きく異なる。

このイベントの前後では、書籍の背景が違うので損得(Railsの取捨選択)を考えて読む。

Rails開発者のDHHについても言及されている。

Railsは、2004年以前のまだ未実現のRDBのベストプラクティス(migrationによるRDB管理)を盛り込んでいる。

つまりは、Rails誕生の2004年以前のベストプラクティスのどこまでをRails自体に盛り込まれているか。

逆に盛り込まれていないものに対しては、何故なのか。背景を理解する。

## 2.実際に手を動かしてアウトプットをつくる

## デールの円錐

[https://www.ladea.jp/b-gak-006/]

- 読んだだけ 2週間後は、10%覚えている
- 読んだだけ+耳から聞く 20%覚えている
- 読んだ+聞いた+見た 30%覚えている
- 読んだ+聞いた+ロケーションを見た+デモンストレーションを見た 50%
- 上記+相手に話す 70%
- 上記 + やってみる 90%

スピードが落ちるが、習熟度がグッと上がる。

[https://twitter.com/t_wada/status/9000231741]

上記のtweetについても言及

写経するだけではなく、疑問点があったらコミットログや本に書き込む。

書籍を能動的に読む。

## 3.毎年少なくとも一つの言語を学習する

### 学習する言語にテーマ性を持たせる。

- 仕事で使っている言語をマスターする。
-- 流行りの言語
-- thechnology radarを参照して、ADOPT(実践) - TRIAL(挑戦的) - ASSESS(視界には入れておく) - HOLD(やめておけ)の順で優先順位を決める

自分がrubyプログラマーだとする。

haskellのような構造が全く違う言語は、酸欠になりやすい。

かといってrubyと似ている言語だと学びが浅い。

rubyの場合、動的型付、スクリプト言語である。

つまり静的型付、関数型だと学びか多い。

このように選択する。

### 技術書と英語について

英語ができれば今は有利

将来は英語ができることがスタンダートになる。

> 英語ができるようになるというのは、「大きな図書館の鍵」を渡されるようなものです。

> 一人ひとりの人生にいろんな可能性を与えてくれます。

## 4.身の回りをプログラミング対象にする

例としては、和田さんの`翻訳`作業

- バージョン管理
- 原文はスクリプトで取得
- markdownしよう
- herokuで自動デプロイ

## 5.アウトプットを行う

このプレゼンも毎回アップデートしている。

かつ、質問を受けてインプットも受けている。

### 量は質を転化する

プログラミングは量をこなすこと。

アウトプットのチャネル

- twitter
- blog,Qiita
- 雑誌記事(Web,紙媒体,電子媒体)
- 書籍(共著,翻訳,監修,単著)
- 講演(社内勉強会)

プログを書くのは、最も軸にしてほしい

しかし、ブログは未解決情報ではないので、公開に至らず。。。

> 情報発信、blog、発表、公開などは、数学の未解決問題の証明ではなく、料理のようなもの

実際にチャレンジしたことが価値がある。

プログラミングは、環境によって動作が大きく異なるので、5年以上前の良質なエントリーよりも、当日の多少粗悪なエントリーの方が価値があることが多い。

また、良質なエントリーをひたすら更新し続けることも有効

ブログによって良質なアウトプットを続けていると、雑誌の執筆の仕事が入る。

### 講演する

資料を作成

できればライブコーディングで(印象が最も残りやすい)

- 壇上ではネットワークが繋がらな
- ライブコーディング中にものが倒れる

不足の事態になりやすく、それに対する準備する力がつく。

# もう一つは和田さんのプログラマーでいるためのHotTO

## 1.毎日コードを書く

Write Code Every Day

- 毎日コードを書くこと
- 意味のあるコードを書くこと
- 深夜24時前に終わらせる
- githubで全てOSSにする

その結果の変化

- 必要最小限のコードへの集中
- プログラミングの習慣化:githubに草を生やすのが目的ではない
- 不安との戦い:毎日コードを書いて、進んでいるという実感は実際の進捗と同じように大切だ
- 週末の過ごし方:週末は平日の延長線になった
- バックグラウンド処理:散歩中、シャワー中に常にバックグラウンドで考えるようになり、良いアイデアが浮かぶようになった。
- コンテクストスイッチ:以前は週に一回だったが、毎日やるのでスイッチの変化の必要がない
- ワークライフバランス:毎日続けるには、やり過ぎてもやらな過ぎてもよくない。適量が大切
- 周りからの理解:毎日コードを書くと周りからの理解を得られる。
- どれだけコードを書いたか:この習慣を続けると書くコードやアウトプットは自分でも覚えられないくらいの量になる。

### 時間を作るためには

住む場所を工夫する。

始発駅に住むと、座ることができる。

## 2.年下から学ぶ

> 一生プログラマーでいられるかどうかは、言い換えれば、年下から学べるか否か

好き->できる->好き->できる ->.......

ループすると技術のタコツボ化

### ベンチマークとアンラーニング

- 定期的に自分のスキルの棚卸
- 積極的に外部に出て、自分のスキルを相対化する
- 使う道具を定期的に変える
- 未知のコミュニティに参加する
- 若者から学ぶ
- 若者と同じ土俵で学ぶ

**一番学びが大きいのは、ベアプログラミング**

ベテランにはアンラーニングのチャンス

## 3.過去から未来をみる

技術は「らせん」

3層アーキテクチャ -> REST(3層とは別物) -> Graphql(2層アーキテクチャ)

ベテランは、削除された1層分は、なぜ削除されたのか理解できる。

これは、ベテランの唯一のアドバンテージ

**これを忘れると「老害」となる**

**「T字型」ではなく複数の話を**

これは、T字型は外部の圧力がかかる恐れがある。

つまり、一本折れたら死ぬことを意味する。

複数の柱は、別ベクトルで持つこと。

一つは変化の早い技術

もう一つは枯れた技術

## 4.人の作る渦にいる

組織の時代から個人の時代へ

github登場から突出した個人が、責任を持ってチームを持つ。

個が多く集まると、イノベーションが加速する。

ロードマップ指向からエコシステム指向へ

> 「エコシステム」は熱帯雨林のように、食い合いつつ強制しあう様々なプレイヤーが、自分のためだけの個別の意思決定をして、その相互作用で技術が発展していく。

> 普通の人は「ロードマップ」の中では真ん中を進むべきで、「エコシステム」の中では真ん中を避けるべきだ

例として、「ロードマップ」はAppleの中ではswiftが中心になってる。Object-cで頑張ることは「ロードマップ」の外にいることになる。

> Worse Is Better(悪い方が良い)

## 大事なことに集中する

年をとると、どんどん自分の時間に減る。

つまり、何かに選択と集中しなくてはならない。

# 終わりに

**技術を学ぶのではなく、技術の学び方を学ぶ**

# 質疑応答

## Q.何を持って技術を学び終えるのか

A.中級を完了し、アプリケーションかライブラリの公開をする。

つまり書籍から離れて書く。

また、リファレンスを参照せずにコードがそこそこ書けると、マスターした指標になる。

## Q.書籍はどこまで遡ればいいのか?

A.20年前まででいい。

それ以前は、技術の作者の書いた本のみを読む。

例として、達人プログラマーの心構えは現役で通用する。

しかし、コード部分は完璧に使えないものになってる。

# XSS

XSS 脆弱性は、クロスサイト・スクリプティング脆弱性の略称
XSS 脆弱性は、意図しない HTML、JavaScript、CSS の変更ができる脆弱性
コードを修正することで、機能が低下することをリグレッションと言う

# ハッシュ関数

作られたハッシュ値から元の値を推測することができない、または、計算に莫大な時間がかかる
同じハッシュ値をもつ 2つのデータを見つけることが難しい
以上 2 つの性質を持つことが求められます。前者のことを原像計算困難性といい、後者のことを衝突困難性といいます。

# PHPカンファレンス

## OpneID

## ID Tokenとは

ユーザー認証情報を含む改ざん検知用の署名付きToken

JSON Web Tokenフォーマット

## OAuthとの違い

|リスク|トークンの置き換え攻撃|
事象:Access Tokenを置き換えることで悪意あるユーザーを認証させて「乗っ取らせ」を行う
対策:Access Toke
OAutは「認可」の仕組みであり「認証」のためのセキュリティ対策がしようとして組み込まれていない

header関数に夜locationヘッダーのリダイレクト
stateパラメーターに夜
open ID Connect
http://www.buildinsider.net/enterprise/openid/connect

# グラブル

アクセス数がすごい

・New Relicで調査
サーバーでの処理時間がリアルタイムでわかるツール
most time consuming が上位
バトルの処理回数が多い
バトルの処理時間が長い
・バトル処理全般について
・レスポンスタイムが高い

->
スキルの計算処理が時間がかかる
プロファイラで処理分析
今回はXHProfを使用
PHPのプロファイラ
スキル計算処理がメモリを消費し、処理時間も長い
**スキル計算の高速化**
**CSVの取得処理の効率化**

実際に改修した内容
・スキルが3種類あって、スキルの組み合わせが複雑
・スキルの計算処理が重いし、スキルの数も多い
・DBの負荷対策から知見を得た
DBからKVSに乗せる。(一般的な負荷対策をえる)
計算結果をkvsに載せると計算処理が省ける
キーの持ち方
「バトルID」と「ユーザーID」を組み合わせて一意なことを保証する
